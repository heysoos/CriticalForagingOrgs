from plotting import plot_food
from plotting import plot_organism

import numpy as np
import operator
from itertools import combinations
import matplotlib.pyplot as plt
import copy

from math import atan2
from math import cos
from math import degrees
from math import floor
from math import radians
from random import random
from random import sample
from random import randint
from math import sin
from math import sqrt
from random import uniform

import os
import pickle
import time


# --- CLASSES ----------------------------------------------------------------+

class ising:
    # Initialize the network
    def __init__(self, settings, netsize, Nsensors=2, Nmotors=2, name=None):  # Create ising model

        self.size = netsize
        self.Ssize = Nsensors  # Number of sensors
        self.Msize = Nmotors  # Number of sensors
        self.radius = settings['org_radius']

        self.h = np.zeros(netsize)

        # self.J = np.zeros((self.size, self.size))

        self.J = np.random.random((self.size, self.size))*2 - 1
        self.J = (self.J + self.J.T) / 2
        np.fill_diagonal(self.J, 0)

        self.max_weights = 2

        self.maxRange = sqrt((settings['x_max'] - settings['x_min']) ** 2 +
                             (settings['y_max'] - settings['y_min']) ** 2)

        self.randomize_state()

        self.xpos = uniform(settings['x_min'], settings['x_max'])  # position (x)
        self.ypos = uniform(settings['y_min'], settings['y_max'])  # position (y)

        self.r = uniform(0, 360)  # orientation   [0, 360]
        self.v = uniform(0, settings['v_max']/3)  # velocity      [0, v_max]
        self.dv = uniform(-settings['dv_max'], settings['dv_max'])  # dv

        self.name = name

        self.Beta = 1.0
        self.defaultT = max(100, netsize * 20)

        self.Ssize1 = 1 # FOOD ROTATIONAL SENSOR: sigmoid(theta)
        self.Ssize2 = 1 # FOOD DISTANCE SENSOR: sigmoid(distance)
        self.Ssize3 = 1 # DIRECTIONAL NEIGHBOUR SENSOR: dot-product distance normalized, see self.org_sens

        self.Msize1 = int(self.Msize/2)  # dv motor neuron


        # MASK USED FOR SETTINGS J/h TO 0
        self.maskJ = np.ones((self.size, self.size), dtype=bool)
        self.maskJ[0:self.Ssize, 0:self.Ssize] = False
        self.maskJ[-self.Msize: -self.Msize] = False
        self.maskJ[0:self.Ssize, -self.Msize:] = False
        np.fill_diagonal(self.maskJ, 0)
        self.maskJ = np.triu(self.maskJ)

        self.J[~self.maskJ] = 0

        # self.maskJtriu = np.triu(self.maskJ)

        self.disconnect_hidden_neurons(settings)

        self.maskh = np.ones(self.size, dtype=bool)
        self.maskh[0:self.Ssize] = False

        self.d_food = self.maxRange  # distance to nearest food
        self.r_food = 0  # orientation to nearest food
        self.org_sens = 0 # directional, 1/distance ** 2 weighted organism sensor
        self.fitness = 0

        self.assign_critical_values(settings)

        self.Update(settings, 0)

    def get_state(self, mode='all'):
        if mode == 'all':
            return self.s
        elif mode == 'motors':
            return self.s[-self.Msize:]
        elif mode == 'sensors':
            return self.s[0:self.Ssize]
        elif mode == 'non-sensors':
            return self.s[self.Ssize:]
        elif mode == 'hidden':
            return self.s[self.Ssize:-self.Msize]

    def get_state_index(self, mode='all'):
        return bool2int(0.5 * (self.get_state(mode) + 1))

    # Randomize the state of the network
    def randomize_state(self):
        self.s = np.random.randint(0, 2, self.size) * 2 - 1
        self.s = np.array(self.s, dtype=float)

        # SEE SENSOR UPDATE
        # random sensor states are generated by considering the sensor limitations

        random_rfood = (np.random.rand() * 360) - 180
        self.s[0] = random_rfood / 180

        random_dfood = np.random.rand() * self.maxRange
        self.s[1] = np.tanh(self.radius / (random_dfood ** 2 + 1e-6)) * 2 - 1

        random_dorg = np.random.rand() * self.maxRange
        self.s[2] = np.tanh((random_dorg)) * 2 - 1

    def randomize_position(self):
        self.observation = self.env.reset()

    # Set random bias to sets of units of the system
    def random_fields(self, max_weights=None):
        if max_weights is None:
            max_weights = self.max_weights
        self.h[self.Ssize:] = max_weights * (np.random.rand(self.size - self.Ssize) * 2 - 1)

    # Set random connections to sets of units of the system
    def random_wiring(self, max_weights=None):  # Set random values for h and J
        if max_weights is None:
            max_weights = self.max_weights
        for i in range(self.size):
            for j in np.arange(i + 1, self.size):
                if i < j and (i >= self.Ssize or j >= self.Ssize):
                    self.J[i, j] = (np.random.rand(1) * 2 - 1) * self.max_weights

    def Move(self, settings):

        # print(self.s[-2:])
        # TODO: velocity coeffecient that can be mutated?
        # UPDATE HEADING - Motor neuron s.[-self.Msize:self.Msize1]
        self.r += (np.sum(self.s[-self.Msize:-self.Msize1]) / 2) * settings['dr_max'] * settings['dt']
        self.r = self.r % 360

        # UPDATE VELOCITY - Motor neuron s.[-self.Msize1:]
        self.v += (np.sum(self.s[-self.Msize1:]) / 2) * settings['dv_max'] * settings['dt']

        if self.v < 0:
            self.v = 0

        if self.v > settings['v_max']:
            self.v = settings['v_max']

        if self.r > settings['r_max']:
            self.r = settings['r_max']

        # print('Velocity: ' + str(self.v) +  str(self.s[-1]))

        # UPDATE POSITION
        dx = self.v * cos(radians(self.r)) * settings['dt']
        dy = self.v * sin(radians(self.r)) * settings['dt']
        self.xpos += dx
        self.ypos += dy

        # torus boundary conditions
        if abs(self.xpos) > settings['x_max']:
            self.xpos = -self.xpos

        if abs(self.ypos) > settings['y_max']:
            self.ypos = -self.ypos

    def UpdateSensors(self, settings):
        # self.s[0] = sigmoid(self.r_food / 180)
        # self.s[1] = sigmoid(self.d_food)

        # normalize these values to be between -1 and 1
        # TODO: make the numberators (gravitational constants part of the connectivity matrix so it can be mutated)
        self.s[0] = self.r_food / 180 # self.r_food can only be -180:180
        # self.s[1] = np.tanh(np.log10(self.radius / (self.d_food ** 2 + 1e-6)))  # self.d_food goes from 0 to ~
        # self.s[2] = np.tanh(np.log10(self.org_sens + 1e-10))
        self.s[1] = np.tanh(self.radius / (self.d_food ** 2 + 1e-6))*2 - 1  # self.d_food goes from 0 to ~
        self.s[2] = np.tanh((self.org_sens))*2 - 1
        # print(self.s[0:3])

    # Execute step of the Glauber algorithm to update the state of one unit
    def GlauberStep(self, i=None):
        if i is None:
            i = np.random.randint(self.size)
        eDiff = 2 * self.s[i] * (self.h[i] + np.dot(self.J[i, :] + self.J[:, i], self.s))
        if self.Beta * eDiff < np.log(1.0 / np.random.rand() - 1):  # Glauber
            self.s[i] = -self.s[i]

    # Compute energy difference between two states with a flip of spin i
    def deltaE(self, i):
        return 2 * (self.s[i] * self.h[i] + np.sum(
            self.s[i] * (self.J[i, :] * self.s) + self.s[i] * (self.J[:, i] * self.s)))

    # Update states of the agent from its sensors
    def Update(self, settings, i=None):
        if i is None:
            i = np.random.randint(self.size)
        if i == 0:
            self.Move(settings)
            self.UpdateSensors(settings)
        elif i >= self.Ssize:
            self.GlauberStep(i)

    def SequentialUpdate(self, settings):
        for i in np.random.permutation(self.size):
            self.Update(settings, i)


    # Update all states of the system without restricted infuences
    def SequentialGlauberStep(self, settings):
        thermalTime = int(settings['thermalTime'])

        self.UpdateSensors(settings) # update sensors at beginning

        # update all other neurons a bunch of times
        for j in range(thermalTime):
            perms = np.random.permutation(range(self.Ssize, self.size))
            for i in perms:
                self.GlauberStep(i)

        self.Move(settings) # move organism at end

    def NoSensorGlauberStep(self):
        perms = np.random.permutation(range(self.Ssize, self.size))
        for i in perms:
            self.GlauberStep(i)

    def DreamSensorGlauberStep(self):
        perms = np.random.permutation(self.size)
        for i in perms:
            self.GlauberStep(i)

    # ensure that not all of the hidden neurons are connected to each other
    def disconnect_hidden_neurons(self, settings):
        numHNeurons = self.size - self.Ssize - self.Msize
        perms = list(combinations(range(self.Ssize, self.Ssize + numHNeurons), 2))
        numDisconnectedEdges = len(list(combinations(range(settings['numDisconnectedNeurons']), 2)))

        for i in range(0, numDisconnectedEdges):
            nrand = np.random.randint(len(perms))
            iIndex = perms[nrand][0]
            jIndex = perms[nrand][1]

            self.J[iIndex,jIndex] = 0
            # self.J[jIndex, iIndex] = 0

            self.maskJ[iIndex, jIndex] = False
            # self.maskJ[jIndex, iIndex] = False

        # self.maskJtriu = np.triu(self.maskJ)

    def assign_critical_values(self, settings):
        # LOAD ISING CORRELATIONS
        # filename = 'correlations-ising2D-size400.npy'
        # Cdist = np.load(filename)
        Cdist = settings['Cdist']

        self.m1 = np.zeros(self.size)
        self.C1 = np.zeros((self.size, self.size))
        for ii in range(self.size):
            for jj in range(max(ii + 1, self.Ssize), self.size):
                ind = np.random.randint(len(Cdist))
                self.C1[ii, jj] = Cdist[ind]

    # re-sort the assigned correlations from the critical ising model so that their order matches the order of the
    # actual correlations
    def sort_critical_correlations(self):
        c = self.C
        x = np.arange(np.prod(c.shape)).reshape(c.shape)[self.maskJ]  # index vector
        c = c[self.maskJ]

        c1 = self.C1[self.maskJ]

        orderc = np.argsort(c)
        orderc1 = np.argsort(c1)

        C1_new = np.zeros((self.size, self.size))

        count = 0
        # loop through index vector and re-sort assigned correlations to match order of actual correlations
        for index in x:
            i_index = int(np.floor(index / self.size))
            j_index = int(index % self.size)

            condition = np.subtract(orderc1, orderc[count]) == 0
            C1_index = int(np.extract(condition, orderc1))

            C1_new[i_index, j_index] = c1[C1_index]

            count += 1

        self.C1 = C1_new


class food():
    def __init__(self, settings):
        self.xpos = uniform(settings['x_min'], settings['x_max'])
        self.ypos = uniform(settings['y_min'], settings['y_max'])
        self.energy = 1

    def respawn(self, settings):
        self.xpos = uniform(settings['x_min'], settings['x_max'])
        self.ypos = uniform(settings['y_min'], settings['y_max'])
        self.energy = 1


# --- FUNCTIONS ----------------------------------------------------------------+

def dist(x1, y1, x2, y2):
    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)


def calc_heading(I, food):
    d_x = food.xpos - I.xpos
    d_y = food.ypos - I.ypos
    theta_d = degrees(atan2(d_y, d_x)) - I.r
    theta_d %= 360

    # keep the angles between -180:180
    if theta_d > 180:
        theta_d -= 360
    return theta_d


# Transform bool array into positive integer
def bool2int(x):
    y = 0
    for i, j in enumerate(np.array(x)[::-1]):
        y += j * 2 ** i
    return int(y)


# Transform positive integer into bit array
def bitfield(n, size):
    x = [int(x) for x in bin(int(n))[2:]]
    x = [0] * (size - len(x)) + x
    return np.array(x)


def TimeEvolve(isings, foods, settings, folder, rep):
    T = settings['TimeSteps']
    for I in isings:
        I.position = np.zeros((2, T))

    # Main simulation loop:
    if settings['plot'] == True:
        plt.clf()
        plt.ion()
        fig, ax = plt.subplots()
        # fig.set_size_inches(15, 10)

    for t in range(T):

        # PLOT SIMULATION FRAME
        if settings['plot'] == True and (t % settings['frameSkip']) == 0:
            plot_frame(settings, folder, fig, ax, isings, foods, t, rep)
            plt.pause(1e-5)
            plt.draw()
            plt.cla()

        interact(settings, isings, foods)

        for I in isings:
            I.SequentialGlauberStep(settings)
            I.position[:, t] = [I.xpos, I.ypos]

# Dynamical Critical Learning Algorithm for poising units in a critical state
def HomeostaticGradient(isings, foods, settings, folder, rep):
    T = settings['TimeSteps']
    for I in isings:
        I.m = np.zeros(I.size)
        I.c = np.zeros((I.size, I.size))
        I.C = np.zeros((I.size, I.size))
        I.var = np.zeros(I.size)

        I.position = np.zeros((2, T))

    # Main simulation loop:
    if settings['plot'] == True:
        plt.clf()
        plt.ion()
        fig, ax = plt.subplots()
        # fig.set_size_inches(15, 10)
    # start_time = time.time()
    for t in range(T):
        # print('Time = ' + str(t))
        # PLOT SIMULATION FRAME
        if settings['plot'] == True and (t % settings['frameSkip']) == 0:
            plot_frame(settings, folder, fig, ax, isings, foods, t, rep)
            plt.pause(1e-5)
            plt.draw()
            plt.cla()

        # check_eat_food(settings, isings, foods)
        # calc_closest_food(isings, foods)
        interact(settings, isings, foods)

        for I in isings:
            I.SequentialGlauberStep(settings)
            I.position[:, t] = [I.xpos, I.ypos]
            I.m += I.s

            for iS in range(I.size):
                I.c[iS, iS + 1:] += I.s[iS] * I.s[iS + 1:]
                # I.c[iS, iS] += I.s[iS] ** 2
    # print('Time Elapsed: ' + str(int(time.time() - start_time)))

        # print(isings[0].position[:,t])

    # CALCULATE CORRELATIONS AND MEAN ACTIVATIONS TO GET: dh, dJ
    for I in isings:

        I.m /= T
        I.c /= T

        for iS in range(I.size):
            I.C[iS, iS + 1:] = I.c[iS, iS + 1:] - I.m[iS] * I.m[iS + 1:]
            # I.var[iS] = I.c[iS, iS] - I.m[iS] ** 2

        # resort correlations C1 to match the order of that of the actual C
        # TODO: Does this actually work the way it's supposed to?
        I.sort_critical_correlations()

        I.dh = I.m1 - I.m
        I.dJ = I.C1 - I.C
        # I.dvar = I.var - 1

        I.dh[~I.maskh] = 0
        # I.dvar[~I.maskh] = 0
        I.dJ[~I.maskJ] = 0

def EvolutionLearning(isings, foods, settings, Iterations = 1):

    if settings['save_data'] == True:
        folder = 'save/sim-' + time.strftime("%Y%m%d-%H%M%S") + '/'
        if not os.path.exists(folder):
            os.makedirs(folder)
            os.makedirs(folder + 'isings')
            os.makedirs(folder + 'stats')
            os.makedirs(folder + 'figs')
    else:
        folder = None

    count = 0
    for rep in range(Iterations):
        TimeEvolve(isings, foods, settings, folder, rep)
        if settings['plot'] == True:
            plt.clf()

        # mutationrate[0], mutationrate[1] = mutation_rate(isings)

        if rep % settings['evolution_rate'] == 0 and settings['save_data'] == True:

            fitness, fitness_stat = food_fitness(isings)
            eat_rate = np.sum(fitness_stat)/settings['TimeSteps']

            if settings['mutateB']:
                Beta = []
                for I in isings:
                    Beta.append(I.Beta)

                mBeta = np.mean(Beta)
                stdBeta = np.std(Beta)

        # save rate equal to evolutation rate
        # TODO: Add eatrate; make this useful
            mutationrate = None
            fitm = None
            fitC = None
            print(count, '|', eat_rate, mBeta, stdBeta)
            save_sim(folder, isings, fitness_stat, mutationrate, fitC, fitm, rep)

        if rep > settings['TimeStepsGrowth']:
            settings['plot'] = True

        count += 1

        if rep % settings['evolution_rate'] == 0:
            isings = evolve(settings, isings, rep)

def CriticalLearning(isings, foods, settings, Iterations=1):
    # settings['TimeSteps'] = 10
    mutationrate = np.zeros(2)

    u = 0.01

    if settings['save_data'] == True:
        folder = 'save/sim-' + time.strftime("%Y%m%d-%H%M%S") + '/'
        if not os.path.exists(folder):
            os.makedirs(folder)
            os.makedirs(folder + 'isings')
            os.makedirs(folder + 'stats')
            os.makedirs(folder + 'figs')
    else:
        folder = None

    count = 0
    l2 = 0.004
    for rep in range(Iterations):
        # CALCULATE self.dh AND self.dJ
        HomeostaticGradient(isings, foods, settings, folder, rep)
        if settings['plot'] == True:
            plt.clf()

        mutationrate[0], mutationrate[1] = mutation_rate(isings)
        fitness, fitness_stat = food_fitness(isings)
        eat_rate = np.sum(fitness_stat)/settings['TimeSteps']

        fitness = (fitness + 1) / 2

        if rep % settings['evolution_rate'] == 0: # save rate linked with evolutation rate
            fitC, fitm = calc_fit(isings, mutationrate, eat_rate, count)
            if settings['save_data'] == True:
                save_sim(folder, isings, fitness_stat, mutationrate, fitC, fitm, rep)

        if rep > settings['TimeStepsGrowth']:
            settings['plot'] = True

        count += 1

        iOrg = 0
        for I in isings:
            # I.J += fitness[iOrg] * (u * I.dJ - l2 * I.J)
            # I.h += fitness[iOrg] * (u * I.dh - l2 * I.h)
            I.J += u * I.dJ - l2 * I.J
            I.h += u * I.dh - l2 * I.h


            Vmax = I.max_weights
            for i in range(I.size):
                if np.abs(I.h[i]) > Vmax:
                    I.h[i] = Vmax * np.sign(I.h[i])
                for j in np.arange(i + 1, I.size):
                    if np.abs(I.J[i, j]) > Vmax:
                        I.J[i, j] = Vmax * np.sign(I.J[i, j])
            iOrg += 1

        if settings['evolution_toggle'] == True:
            if rep % settings['evolution_rate'] == 0:
                isings = evolve(settings, isings, rep)
        else:
            for I in isings:
                I.fitness = 0


def plot_frame(settings, folder, fig, ax, isings, foods, time, rep):
    # fig, ax = plt.subplots()
    fig.set_size_inches(9.6, 5.4)

    plt.xlim([settings['x_min'] + settings['x_min'] * 0.25, settings['x_max'] + settings['x_max'] * 0.25])
    plt.ylim([settings['y_min'] + settings['y_min'] * 0.25, settings['y_max'] + settings['y_max'] * 0.25])

    # PLOT ORGANISMS
    for I in isings:
        plot_organism(settings, I.xpos, I.ypos, I.r, ax)

    # PLOT FOOD PARTICLES
    for food in foods:
        plot_food(settings, food.xpos, food.ypos, ax)

    # MISC PLOT SETTINGS
    ax.set_aspect('equal')
    frame = plt.gca()
    frame.axes.get_xaxis().set_ticks([])
    frame.axes.get_yaxis().set_ticks([])

    plt.figtext(0.025, 0.90, r'T_STEP: ' + str(time))

    # if settings['plotLive'] == True:
    #     plt.show()
    if settings['save_data'] == True:
        filename = folder + 'figs/iter-' + str(rep) + 'time-' + str(time) + '.png'
        plt.savefig(filename, dpi=100)
    # plt.close()

def calc_fit(isings, mutationrate, fitness_stat, count):
    fitC = []
    fitm = []
    Jmean = []
    hmean = []
    for I in isings:
        fitC.append(np.mean(np.abs(
            I.C1[I.maskJ] - I.C[I.maskJ])))

        fitm.append(np.mean(np.abs(I.m1[I.Ssize:] - I.m[I.Ssize:])))

        Jmean.append(np.max(np.abs(I.J)))
        hmean.append(np.max(np.abs(I.h[I.Ssize:])))
    fitC = np.max(fitC)
    fitm = np.mean(fitm)
    fit = fitC + fitm
    Jmean = np.mean(Jmean)  # average of the highest J values
    hmean = np.mean(hmean)  # average of the highest h values

    print(count, '|', fitness_stat, fitC, fitm, '|', Jmean, hmean, '|', mutationrate[1], mutationrate[0])


    return fitC, fitm

def food_fitness(isings):
    fitness = []
    for I in isings:
        fitness.append(I.fitness)

    fitness = np.array(fitness, dtype='float')
    mask = fitness != 0

    fitnessN = copy.deepcopy(fitness)
    fitnessN[mask] /= float(np.max(fitnessN))
    # fitness[mask] /= float(np.max(fitness))

    return fitnessN, fitness

def evolve(settings, I_old, gen):
    size = settings['size']
    nSensors = settings['nSensors']
    nMotors = settings['nMotors']

    I_sorted = sorted(I_old, key=operator.attrgetter('fitness'), reverse=True)
    I_new = []

    alive_num = int(settings['pop_size'] - settings['numKill'])
    elitism_num = int(alive_num/2) # only the top half of the living orgs can duplicate

    numMate = int(settings['numKill'] * settings['mateDupRatio'])
    numDup = settings['numKill'] - numMate

    for i in range(0, alive_num):
        I_new.append(I_sorted[i])

    # --- GENERATE NEW ORGANISMS ---------------------------+
    orgCount = settings['pop_size'] + gen * settings['numKill']

    # DUPLICATION OF ELITE POPULATION
    for dup in range(0, numDup):
        candidateDup = range(0, elitism_num)
        random_index = sample(candidateDup, 1)[0]

        name = I_sorted[random_index].name
        I_new.append(ising(settings, size, nSensors, nMotors, name))

        I_new[-1].J = I_sorted[random_index].J
        I_new[-1].h = I_sorted[random_index].h
        I_new[-1].maskJ = I_sorted[random_index].maskJ
        # I_new[-1].maskJtriu = I_sorted[random_index].maskJtriu

        try:
            I_new[-1].C1 = I_sorted[random_index].C1
        except NameError:
            pass


        mutate(settings, I_new[-1])

        # random mutations in duplication

    # MATING OF LIVING POPULATION DOUBLE DIPPING ELITE
    for mate in range(0, numMate):
        # TODO: negative weight mutations?!
        # SELECTION (TRUNCATION SELECTION)
        candidatesMate = range(0, len(I_new)) # range(0, alive_num) to avoid double dipping
        random_index = sample(candidatesMate, 2)
        org_1 = I_sorted[random_index[0]]
        org_2 = I_sorted[random_index[1]]

        # CROSSOVER
        J_new = np.zeros((size, size))
        h_new = np.zeros(size)

        # load up a dummy maskJ which gets updated
        maskJ_new = np.zeros((size, size), dtype=bool)

        crossover_weight = random()

        if settings['mutateB']:
            deltaB = np.random.uniform(
                1 - float(settings['deltaB']),
                1 + float(settings['deltaB']))

            Beta_new = (crossover_weight * org_1.Beta) + \
                            ((1 - crossover_weight) * org_2.Beta) * deltaB
        else:
            Beta_new = 1

        for iJ in range(0, size):
            crossover_weight = random()

            h_new[iJ] = (crossover_weight * org_1.h[iJ]) + \
                        ((1 - crossover_weight) * org_2.h[iJ])

            for jJ in range(iJ + 1, size):
                crossover_weight = random()

                # check if these hidden neurons are disconnected to begin with
                if org_1.maskJ[iJ, jJ] != 0 and org_2.maskJ[iJ, jJ] != 0:
                    J_new[iJ, jJ] = (crossover_weight * org_1.J[iJ, jJ]) + \
                                    ((1 - crossover_weight) * org_2.J[iJ, jJ])
                    maskJ_new[iJ, jJ] = org_1.maskJ[iJ, jJ]
                elif np.random.randint(2) == 0:
                    J_new[iJ, jJ] = org_1.J[iJ, jJ]
                    maskJ_new[iJ, jJ] = org_1.maskJ[iJ, jJ]
                else:
                    J_new[iJ, jJ] = org_2.J[iJ, jJ]
                    maskJ_new[iJ, jJ] = org_2.maskJ[iJ, jJ]

                if np.abs(J_new[iJ, jJ]) > org_1.max_weights:
                    J_new[iJ, jJ] = org_1.max_weights



        name = 'gen[' + str(gen) + ']-org[' + str(orgCount) + ']'
        I_new.append(ising(settings, size, nSensors, nMotors, name))

        I_new[-1].Beta = Beta_new
        I_new[-1].J = J_new
        I_new[-1].h = h_new
        I_new[-1].maskJ = maskJ_new

        mutate(settings, I_new[-1])

        orgCount += 1

    for I in I_new:
        I.fitness = 0

    return I_new

def save_sim(folder, isings, fitness_stat, mutationrate, fitC, fitm, gen):
    filenameI = folder + 'isings/gen[' + str(gen) + ']-isings.pickle'
    filenameS = folder + 'stats/gen[' + str(gen) + ']-stats.pickle'

    if type(mutationrate) is not type(None):
        mutationh = mutationrate[0]
        mutationJ = mutationrate[1]
    else:
        mutationh = None
        mutationJ = None


    pickle_out = open(filenameI, 'wb')
    pickle.dump(isings, pickle_out)
    pickle_out.close()

    pickle_out = open(filenameS, 'wb')

    if type(mutationrate) is not type(None):
        pickle.dump((fitness_stat, (mutationh, mutationh ** 2), (mutationJ, mutationJ ** 2), fitC, fitm), pickle_out)
        pickle_out.close()
    else:
        pickle.dump(fitness_stat, pickle_out)
        pickle_out.close()


def mutation_rate(isings):
    for I in isings:

        hmutation = np.abs(I.dh[I.maskh])
        Jmutation = np.abs(I.dJ[I.maskJ])

    hmutation = np.mean(hmutation)
    Jmutation = np.mean(Jmutation)
    return hmutation, Jmutation

def sigmoid(x):
    y = 1/(1 + np.exp(-x))
    return y

def logit(x):
    y = np.log(x / (1 - x))
    return y

def check_eat_food(settings, isings, foods):
    for food in foods:
        for I in isings:

            food_org_dist = dist(I.xpos, I.ypos, food.xpos, food.ypos)

            # EAT/RESPAWN FOOD
            if food_org_dist <= 0.075:
                I.fitness += food.energy
                food.respawn(settings)

        # RESET DISTANCE AND HEADING TO NEAREST FOOD SOURCE
        I.d_food = I.maxRange
        I.r_food = 0

def calc_closest_food(isings, foods):
    for food in foods:
        for I in isings:

            # CALCULATE DISTANCE TO SELECTED FOOD PARTICLE
            food_org_dist = dist(I.xpos, I.ypos, food.xpos, food.ypos)

            # DETERMINE IF THIS IS THE CLOSEST FOOD PARTICLE
            if food_org_dist < I.d_food:
                I.d_food = food_org_dist
                I.r_food = calc_heading(I, food)

#TODO: double check if this is working as intended!
def interact(settings, isings, foods):
    for I in isings:
        I.d_food = I.maxRange
        I.r_food = 0
        I.org_sens = 0

        for food in foods:
            food_org_dist = dist(I.xpos, I.ypos, food.xpos, food.ypos)

            # EAT
            if food_org_dist <= settings['org_radius']:
                I.fitness += food.energy
                food.respawn(settings)

            # DETERMINE IF THIS IS THE CLOSEST FOOD PARTICLE
            if food_org_dist < I.d_food:
                I.d_food = food_org_dist
                I.r_food = calc_heading(I, food)

        for I2 in isings:

            if I != I2:
                org_org_dist = dist(I.xpos, I.ypos, I2.xpos, I2.ypos)
                org_org_heading = calc_heading(I, I2)

                # implement a directional sensor
                if abs(org_org_heading) > 90:
                    dot_org_heading = 0
                else:
                    dot_org_heading = np.cos(np.deg2rad(org_org_heading))

                I.org_sens += ((dot_org_heading * I.radius) / (org_org_dist + 1e-6) ** 2)

# mutate the connectivity matrix of an organism by stochastically adding/removing an edge
def mutate(settings, I):
    # ADDS/REMOVES RANDOM EDGE DEPENDING ON SPARSITY SETTING, RANDOMLY MUTATES ANOTHER RANDOM EDGE

    # expected number of disconnected edges
    numDisconnectedEdges = len(list(combinations(range(settings['numDisconnectedNeurons']), 2)))
    totalPossibleEdges = len(list(combinations(range(I.size - I.Ssize - I.Msize), 2)))

    # number of (dis)connected edges
    connected = copy.deepcopy(I.maskJ)

    disconnected = ~connected
    np.fill_diagonal(disconnected, 0)
    disconnected = np.triu(disconnected)

    # things that need to be connected and not flagged to change
    connected[0:I.Ssize, :] = 0
    connected[:, -I.Msize:] = 0
    # things that need to be disconnected and not flagged to change
    disconnected[0:I.Ssize, -I.Msize:] = 0
    disconnected[0:I.Ssize, 0:I.Ssize] = 0

    numEdges = np.sum(connected)
    # positive value means too many edges, negative value means too little
    edgeDiff = numEdges - (totalPossibleEdges - numDisconnectedEdges)
    # edgeDiff = numEdges - numDisconnectedEdges

    prob = sigmoid(edgeDiff)  # probability near 1 means random edge will be removed, near 0 means random edge added
    rand = np.random.rand()

    if prob >= rand:
        # remove random edge
        i, j = np.nonzero(connected)
        if len(i) > 0:
            randindex = np.random.randint(0, len(i))
            ii = i[randindex]
            jj = j[randindex]

            I.maskJ[ii, jj] = False
            I.J[ii, jj] = 0

            # TODO: is this a good way of making the code multi-purpose?
            try:
                I.C1[ii, jj] = 0
            except NameError:
                pass

        else:
            print('Connectivity Matrix Empty! Mutation Blocked.')

    else:
        # add random edge
        i, j = np.nonzero(disconnected)
        if len(i) > 0:
            randindex = np.random.randint(0, len(i))
            ii = i[randindex]
            jj = j[randindex]

            I.maskJ[ii, jj] = True
            I.J[ii, jj] = np.random.uniform(-1, 1) * I.max_weights
            # I.J[ii, jj] = np.random.uniform(np.min(I.J[I.Ssize:-I.Msize, I.Ssize:-I.Msize]) / 2,
            #                                 np.max(I.J[I.Ssize:-I.Msize, I.Ssize:-I.Msize]) * 2)
            try:
                I.C1[ii, jj] = settings['Cdist'][np.random.randint(0, len(settings['Cdist']))]
            except NameError:
                pass

        else:  # if connectivity matrix is full, just change an already existing edge
            i, j = np.nonzero(connected)

            randindex = np.random.randint(0, len(i))
            ii = i[randindex]
            jj = j[randindex]

            I.J[ii, jj] = np.random.uniform(-1, 1) * I.max_weights

    # MUTATE RANDOM EDGE
    i, j = np.nonzero(I.maskJ)

    randindex = np.random.randint(0, len(i))
    ii = i[randindex]
    jj = j[randindex]

    I.J[ii, jj] = np.random.uniform(-1, 1) * I.max_weights

    # MUTATE LOCAL TEMPERATURE
    if settings['mutateB']:
        deltaB = np.random.uniform(1 - float(settings['deltaB']), 1 + float(settings['deltaB']))
        I.Beta = I.Beta * deltaB


def update_ising(settings, I, t):
    I.SequentialUpdate(settings)
    I.position[:, t] = [I.xpos, I.ypos]
    I.m += I.s

    for iS in range(I.size):
        I.c[iS, iS + 1:] += I.s[iS] * I.s[iS + 1:]

